module thalaswap::weighted_pool {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;

    use aptos_framework::account;
    use aptos_framework::coin::{Self, Coin, MintCapability, BurnCapability};

    use aptos_std::event::{Self, EventHandle};
    use aptos_std::table::{Self, Table};
    use aptos_std::type_info;

    use thalaswap::base_pool;
    use thalaswap::fees;
    use thalaswap::package;

    use thalaswap_math::weighted_math;

    use thala_manager::manager;

    use fixed_point64::fixed_point64::{Self, FixedPoint64};

    friend thalaswap::init;

    ///
    /// Error codes
    ///

    const ERR_UNAUTHORIZED: u64 = 0;

    // Initialization
    const ERR_INITIALIZED: u64 = 1;
    const ERR_UNINITIALIZED: u64 = 2;

    // Pool Conditions
    const ERR_WEIGHTED_POOL_EXISTS: u64 = 3;
    const ERR_WEIGHTED_POOL_NOT_EXISTS: u64 = 4;
    const ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS: u64 = 5;
    const ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS: u64 = 6;
    const ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHT: u64 = 7;
    const ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY: u64 = 8;

    // Swap Conditions
    const ERR_WEIGHTED_POOL_INVALID_SWAP: u64 = 9;
    const ERR_WEIGHTED_POOL_INSUFFICIENT_INPUT: u64 = 10;

    // Management
    const ERR_WEIGHTED_POOL_INVALID_SWAP_FEE: u64 = 11;

    ///
    /// Defaults
    ///

    const DEFAULT_SWAP_FEE_BPS: u64 = 30;

    ///
    /// Constants
    ///

    const POOL_TOKEN_DECIMALS: u8 = 8;
    const MINIMUM_LIQUIDITY: u64 = 100;

    const BPS_BASE: u64 = 10000;

    ///
    /// Resources
    ///

    // The boring code can be generated by the one-liner python script:
    // python3 -c "print('\n'.join(\"struct Weight_\" + str((i*5) + \" {}\" for i in range(1,20)))"
    struct Weight_5 {}
    struct Weight_10 {}
    struct Weight_15 {}
    struct Weight_20 {}
    struct Weight_25 {}
    struct Weight_30 {}
    struct Weight_35 {}
    struct Weight_40 {}
    struct Weight_45 {}
    struct Weight_50 {}
    struct Weight_55 {}
    struct Weight_60 {}
    struct Weight_65 {}
    struct Weight_70 {}
    struct Weight_75 {}
    struct Weight_80 {}
    struct Weight_85 {}
    struct Weight_90 {}
    struct Weight_95 {}

    /// Token issued to LPs represnting fractional ownership of the pool
    struct WeightedPoolToken<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> {}

    struct WeightedPool<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has key {
        asset_0: Coin<Asset0>,
        asset_1: Coin<Asset1>,
        asset_2: Coin<Asset2>,
        asset_3: Coin<Asset3>,

        weight_0: u64,
        weight_1: u64,
        weight_2: u64,
        weight_3: u64,

        // We also store `1 / (1 - swap_fee_ratio)` to save on gas on fee calculations in `swap_exact_out`
        swap_fee_ratio: FixedPoint64,
        inverse_negated_swap_fee_ratio: FixedPoint64,

        pool_token_mint_cap: MintCapability<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        pool_token_burn_cap: BurnCapability<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,

        reserved_lp_coin: Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,

        events: WeightedPoolEvents<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>,
    }

    struct WeightedPoolLookup has key {
        // key: LP token type_name, value: WeightedPoolInfo
        // this is used to help LP oracle to query the status of a pool using LP token name
        name_to_pool: Table<String, WeightedPoolInfo>,

        // key: unique pool ID, value: LP token type_name
        // this is to help DEX aggregator (e.g. Hippo) to iterate all pools
        id_to_name: Table<u64, String>,

        // Pool ID increments for each new pool
        next_id: u64,
    }

    /// Stores the status of a pool without "CoinType" generic type
    /// Can be used to query the status of a pool by LP token name
    struct WeightedPoolInfo has copy, store, drop {
        balances: vector<u64>,
        weights: vector<u64>,
        lp_coin_supply: u64
    }

    struct WeightedPoolParams has key {
        default_swap_fee_ratio: FixedPoint64,
        param_change_events: EventHandle<WeightedPoolParamChangeEvent>
    }

    ///
    /// Events
    ///

    /// Event emitted when a pool is created
    struct WeightedPoolCreationEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        creator: address,
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
        minted_lp_coin_amount: u64,
        swap_fee_bps: u64,
    }

    /// Event emitted when a liquidity is added to a pool
    struct AddLiquidityEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
        minted_lp_coin_amount: u64,
    }

    /// Event emitted when a liquidity is removed from a pool
    struct RemoveLiquidityEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
        burned_lp_coin_amount: u64,
    }

    /// Event emitted when a swap is executed
    struct SwapEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        idx_in: u64,
        idx_out: u64,
        amount_in: u64,
        amount_out: u64,
        fee_amount: u64,
        pool_balance_0: u64,
        pool_balance_1: u64,
        pool_balance_2: u64,
        pool_balance_3: u64,
    }

    /// Event emitted when a protocol parameter is changed
    struct WeightedPoolParamChangeEvent has drop, store {
        name: String,

        prev_value: u64,
        new_value: u64
    }

    struct WeightedPoolEvents<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has store {
        pool_creation_events: EventHandle<WeightedPoolCreationEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        add_liquidity_events: EventHandle<AddLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        remove_liquidity_events: EventHandle<RemoveLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        swap_events: EventHandle<SwapEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,

        param_change_events: EventHandle<WeightedPoolParamChangeEvent>,
    }

    ///
    /// Initialization
    ///

    public(friend) fun initialize() {
        assert!(!initialized(), ERR_INITIALIZED);

        // Required dependencies
        assert!(base_pool::initialized(), ERR_UNINITIALIZED);

        let resource_account_signer = package::resource_account_signer();
        move_to(&resource_account_signer, WeightedPoolLookup { 
            name_to_pool: table::new(),
            id_to_name: table::new(),
            next_id: 0,
        });
        move_to(&resource_account_signer, WeightedPoolParams {
            default_swap_fee_ratio: fixed_point64::fraction(DEFAULT_SWAP_FEE_BPS, BPS_BASE),
            param_change_events: account::new_event_handle<WeightedPoolParamChangeEvent>(&resource_account_signer),
        });
    }

    ///
    /// Config & Param Management
    ///

    public entry fun set_default_pool_swap_fee_bps(manager: &signer, bps: u64) acquires WeightedPoolParams {
        assert!(manager::is_authorized(manager), ERR_UNAUTHORIZED);
        assert!(initialized(), ERR_INITIALIZED);
        assert!(base_pool::validate_swap_fee(bps), ERR_WEIGHTED_POOL_INVALID_SWAP_FEE);

        let params = borrow_global_mut<WeightedPoolParams>(package::resource_account_address());
        let prev_bps = fixed_point64::decode(fixed_point64::mul(params.default_swap_fee_ratio, BPS_BASE));
        params.default_swap_fee_ratio = fixed_point64::fraction(bps, BPS_BASE);
        event::emit_event<WeightedPoolParamChangeEvent>(
            &mut params.param_change_events,
            WeightedPoolParamChangeEvent { name: string::utf8(b"default_swap_fee_bps"), prev_value: prev_bps, new_value: bps }
        );
    }

    ///
    /// Functions
    ///

    public fun create_weighted_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        account: &signer,
        asset_0: Coin<Asset0>,
        asset_1: Coin<Asset1>,
        asset_2: Coin<Asset2>,
        asset_3: Coin<Asset3>
    ): Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>> acquires WeightedPoolParams, WeightedPoolLookup, WeightedPool {
        assert!(initialized(), ERR_UNINITIALIZED);
        assert!(base_pool::validate_pool_assets<Asset0, Asset1, Asset2, Asset3>(), ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS);
        assert!(!weighted_pool_exists<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(), ERR_WEIGHTED_POOL_EXISTS);

        let weight_0 = get_weight<Weight0>();
        let weight_1 = get_weight<Weight1>();
        let weight_2 = get_weight<Weight2>();
        let weight_3 = get_weight<Weight3>();
        assert!(weight_0 + weight_1 + weight_2 + weight_3 == 100, ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS);

        let amount_0 = coin::value(&asset_0);
        let amount_1 = coin::value(&asset_1);
        let amount_2 = coin::value(&asset_2);
        let amount_3 = coin::value(&asset_3);

        // First two assets & weights are mandatory
        let weights = vector<u64>[weight_0, weight_1];
        let balances = vector<u64>[amount_0, amount_1];
        assert!(amount_0 > 0 && amount_1 > 0, ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS);
        assert!(weight_0 > 0 && weight_1 > 0, ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS);

        // If an Asset is non-null, it must have a non-zero weight & non-zero amount, else assert zero.
        if (base_pool::is_null<Asset2>()) {
            // Only 2 Assets
            assert!(amount_2 == 0 && amount_3 == 0, ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS);
            assert!(weight_2 == 0 && weight_3 == 0, ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS);
        } else if (base_pool::is_null<Asset3>())  {
            // Only 3 Assets
            assert!(amount_2 > 0 && amount_3 == 0, ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS);
            assert!(weight_2 > 0 && weight_3 == 0, ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS);

            vector::push_back(&mut weights, weight_2);
            vector::push_back(&mut balances, amount_2);
        } else {
            // All 4 Assets
            assert!(amount_2 > 0 && amount_3 > 0, ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS);
            assert!(weight_2 > 0 && weight_3 > 0, ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS);
            
            vector::push_back(&mut weights, weight_2);
            vector::push_back(&mut balances, amount_2);

            vector::push_back(&mut weights, weight_3);
            vector::push_back(&mut balances, amount_3);
        };

        let resource_account_signer = package::resource_account_signer();
        let resource_account_address = package::resource_account_address();
        let params = borrow_global<WeightedPoolParams>(resource_account_address);
        let swap_fee_ratio = params.default_swap_fee_ratio;

        let one_fp = fixed_point64::one();
        let inverse_negated_swap_fee_ratio = fixed_point64::div_fp(one_fp, fixed_point64::sub_fp(one_fp, swap_fee_ratio));

        // Create Liquidity
        let initial_lp_coin_amount = fixed_point64::decode_round_down(weighted_math::compute_invariant_weights_u64(&balances, &weights));
        assert!(initial_lp_coin_amount > MINIMUM_LIQUIDITY, ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

        let (pool_token_burn_cap, pool_token_mint_cap) = {
            let (burn_cap, freeze_cap, mint_cap) = coin::initialize<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(
                &resource_account_signer,
                lp_short_name<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(),
                string::utf8(b"THALA-LP"),
                POOL_TOKEN_DECIMALS,
                true
            );

            coin::destroy_freeze_cap(freeze_cap);
            (burn_cap, mint_cap)
        };

        let reserved_lp_coin = coin::mint(MINIMUM_LIQUIDITY, &pool_token_mint_cap);
        let pool = WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3> {
            asset_0, asset_1, asset_2, asset_3,
            weight_0, weight_1, weight_2, weight_3,
            reserved_lp_coin,
            swap_fee_ratio, inverse_negated_swap_fee_ratio,
            pool_token_mint_cap, pool_token_burn_cap,
            events: WeightedPoolEvents {
                pool_creation_events: account::new_event_handle<WeightedPoolCreationEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(&resource_account_signer),
                add_liquidity_events: account::new_event_handle<AddLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(&resource_account_signer),
                remove_liquidity_events: account::new_event_handle<RemoveLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(&resource_account_signer),
                swap_events: account::new_event_handle<SwapEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(&resource_account_signer),
                param_change_events: account::new_event_handle<WeightedPoolParamChangeEvent>(&resource_account_signer),
            },
        };

        event::emit_event<WeightedPoolCreationEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(
            &mut pool.events.pool_creation_events,
            WeightedPoolCreationEvent {
                creator: signer::address_of(account),
                amount_0, amount_1, amount_2, amount_3,
                minted_lp_coin_amount: initial_lp_coin_amount,
                swap_fee_bps: fixed_point64::decode(fixed_point64::mul(swap_fee_ratio, BPS_BASE))
            }
        );

        let lp_coin = coin::mint(initial_lp_coin_amount - MINIMUM_LIQUIDITY, &pool.pool_token_mint_cap);
        move_to(&resource_account_signer, pool);

        update_pool_lookup<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(true);

        lp_coin
    }

    public entry fun set_pool_swap_fee_bps<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(manager: &signer, swap_fee_bps: u64)
    acquires WeightedPool {
        assert!(manager::is_authorized(manager), ERR_UNAUTHORIZED);
        assert!(initialized(), ERR_UNINITIALIZED);
        assert!(base_pool::validate_swap_fee(swap_fee_bps), ERR_WEIGHTED_POOL_INVALID_SWAP_FEE);

        let one_fp = fixed_point64::one();
        let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(package::resource_account_address());
        let prev_swap_fee_bps = fixed_point64::decode(fixed_point64::mul(pool.swap_fee_ratio, BPS_BASE));
        pool.swap_fee_ratio = fixed_point64::fraction(swap_fee_bps, BPS_BASE);
        pool.inverse_negated_swap_fee_ratio = fixed_point64::div_fp(one_fp, fixed_point64::sub_fp(one_fp, pool.swap_fee_ratio));
        event::emit_event<WeightedPoolParamChangeEvent>(
            &mut pool.events.param_change_events,
            WeightedPoolParamChangeEvent { name: string::utf8(b"swap_fee_bps"), prev_value: prev_swap_fee_bps, new_value: swap_fee_bps }
        );
    }

    public fun add_liquidity<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        coin_0: Coin<Asset0>,
        coin_1: Coin<Asset1>,
        coin_2: Coin<Asset2>,
        coin_3: Coin<Asset3>
    ): (Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>, Coin<Asset0>, Coin<Asset1>, Coin<Asset2>, Coin<Asset3>)
    acquires WeightedPool, WeightedPoolLookup {
        assert!(initialized(), ERR_UNINITIALIZED);

        let resource_account_address = package::resource_account_address();
        let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);

        // First two deposits are always be non-zero
        let amount_0 = coin::value(&coin_0);
        let amount_1 = coin::value(&coin_1);
        assert!(amount_0 > 0 && amount_1 > 0, ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

        let amount_2 = coin::value(&coin_2);
        let amount_3 = coin::value(&coin_3);

        let deposits = vector<u64>[amount_0, amount_1];
        if (amount_2 > 0) vector::push_back(&mut deposits, amount_2);
        if (amount_3 > 0) vector::push_back(&mut deposits, amount_3);

        // Number of deposits should match all non-zero balances in the pool
        let balances = pool_balances(pool);
        assert!(vector::length(&balances) == vector::length(&deposits), ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);
        
        // Since `MINIMUM_LIQUIDITY` units are reserved on pool creation, we are certain that `lp_supply > 0
        let lp_supply = base_pool::pool_token_supply<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>();
        let (issued_lp_amount, refunds) = weighted_math::compute_pool_tokens_issued(&deposits, &balances, lp_supply);
        assert!(issued_lp_amount > 0, ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

        // Remove excess deposits
        let refunded_0 = coin::extract(&mut coin_0, *vector::borrow(&refunds, 0));
        let refunded_1 = coin::extract(&mut coin_1, *vector::borrow(&refunds, 1));
        let refunded_2 = coin::extract(&mut coin_2, if (amount_2 > 0) *vector::borrow(&refunds, 2) else 0);
        let refunded_3 = coin::extract(&mut coin_3, if (amount_3 > 0) *vector::borrow(&refunds, 3) else 0);

        // Absorb deposits
        coin::merge(&mut pool.asset_0, coin_0);
        coin::merge(&mut pool.asset_1, coin_1);
        coin::merge(&mut pool.asset_2, coin_2);
        coin::merge(&mut pool.asset_3, coin_3);

        event::emit_event<AddLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(
            &mut pool.events.add_liquidity_events,
            AddLiquidityEvent { amount_0, amount_1, amount_2, amount_3, minted_lp_coin_amount: issued_lp_amount }
        );

        let issued_lp_coin = coin::mint(issued_lp_amount, &pool.pool_token_mint_cap);
        
        update_pool_lookup<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(false);

        (issued_lp_coin, refunded_0, refunded_1, refunded_2, refunded_3)
    }

    public fun remove_liquidity<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        lp_coin: Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>
    ): (Coin<Asset0>, Coin<Asset1>, Coin<Asset2>, Coin<Asset3>) acquires WeightedPool, WeightedPoolLookup {
        assert!(initialized(), ERR_UNINITIALIZED);

        let resource_account_address = package::resource_account_address();
        let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);

        let lp_coin_amount = coin::value(&lp_coin);
        let lp_supply = base_pool::pool_token_supply<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>();

        let amount_0 = weighted_math::compute_asset_amount_to_return(coin::value(&pool.asset_0), lp_coin_amount, lp_supply);
        let amount_1 = weighted_math::compute_asset_amount_to_return(coin::value(&pool.asset_1), lp_coin_amount, lp_supply);
        let amount_2 = if (!base_pool::is_null<Asset2>()) weighted_math::compute_asset_amount_to_return(coin::value(&pool.asset_2), lp_coin_amount, lp_supply) else 0;
        let amount_3 = if (!base_pool::is_null<Asset3>()) weighted_math::compute_asset_amount_to_return(coin::value(&pool.asset_3), lp_coin_amount, lp_supply) else 0;

        let asset_0 = coin::extract(&mut pool.asset_0, amount_0);
        let asset_1 = coin::extract(&mut pool.asset_1, amount_1);
        let asset_2 = if (amount_2 > 0) coin::extract(&mut pool.asset_2, amount_2) else coin::zero<Asset2>();
        let asset_3 = if (amount_3 > 0) coin::extract(&mut pool.asset_3, amount_3) else coin::zero<Asset3>();

        coin::burn(lp_coin, &pool.pool_token_burn_cap);
        event::emit_event<RemoveLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(
            &mut pool.events.remove_liquidity_events,
            RemoveLiquidityEvent { amount_0, amount_1, amount_2, amount_3, burned_lp_coin_amount: lp_coin_amount }
        );
        
        update_pool_lookup<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(false);

        (asset_0, asset_1, asset_2, asset_3)
    }

    /// First 9 type args define the pool to swap against. X is input coin type & Y is output coin type
    public fun swap_exact_in<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X, Y>(coin_in: Coin<X>): Coin<Y> acquires WeightedPool, WeightedPoolLookup {
        assert!(initialized(), ERR_UNINITIALIZED);

        // Ensure Input
        let amount_in = coin::value(&coin_in);
        assert!(amount_in > 0, ERR_WEIGHTED_POOL_INSUFFICIENT_INPUT);

        let (prev_balances, weights) = pool_balances_and_weights<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>();

        let resource_account_address = package::resource_account_address();
        let pool = borrow_global<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);

        let typeof_x = type_info::type_of<X>();
        let typeof_y = type_info::type_of<Y>();
        assert!(typeof_x != typeof_y && !base_pool::is_null<X>() && !base_pool::is_null<Y>(), ERR_WEIGHTED_POOL_INVALID_SWAP);

        let (is_in_0, is_in_1, is_in_2, is_in_3) = (typeof_x == type_info::type_of<Asset0>(), typeof_x == type_info::type_of<Asset1>(), typeof_x == type_info::type_of<Asset2>(), typeof_x == type_info::type_of<Asset3>());
        assert!(is_in_0 || is_in_1 || is_in_2 || is_in_3, ERR_WEIGHTED_POOL_INVALID_SWAP);

        let (is_out_0, is_out_1, is_out_2, is_out_3) = (typeof_y == type_info::type_of<Asset0>(), typeof_y == type_info::type_of<Asset1>(), typeof_y == type_info::type_of<Asset2>(), typeof_y == type_info::type_of<Asset3>());
        assert!(is_out_0 || is_out_1 || is_out_2 || is_out_3, ERR_WEIGHTED_POOL_INVALID_SWAP);

        let idx_in = if (is_in_0) 0 else if (is_in_1) 1 else if (is_in_2) 2 else 3;
        let idx_out = if (is_out_0) 0 else if (is_out_1) 1 else if (is_out_2) 2 else 3;

        // Fee Calculation & Adjust the input amount that is swapped as a result
        let total_fee_amount = fixed_point64::decode(fixed_point64::mul(pool.swap_fee_ratio, amount_in));
        let protocol_fee_amount = fixed_point64::decode(fixed_point64::mul(base_pool::swap_fee_protocol_allocation_ratio(), total_fee_amount));
        let amount_in_post_fee = amount_in - total_fee_amount;

        // Compute Swap Output
        let amount_out = weighted_math::calc_out_given_in_weights_u64(idx_in, idx_out, amount_in_post_fee, &prev_balances, &weights);
        assert!(amount_out < *vector::borrow(&prev_balances, idx_out) , ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

        // Absorb Protocol Fees
        fees::absorb_fee(coin::extract(&mut coin_in, protocol_fee_amount));

        // Absorb Swapped In Asset. Yield is provided to LPs by their implicit increased in value with the lp fees included in `coin_in`
        deposit_to_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X>(resource_account_address, idx_in, coin_in);

        // Extract Swapped Out Asset
        let coin_out = extract_from_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, Y>(resource_account_address, idx_out, amount_out);

        let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
        
        event::emit_event<SwapEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(
            &mut pool.events.swap_events,
            SwapEvent {
                idx_in, idx_out,
                amount_in, amount_out,
                fee_amount: total_fee_amount,
                pool_balance_0: coin::value(&pool.asset_0),
                pool_balance_1: coin::value(&pool.asset_1),
                pool_balance_2: coin::value(&pool.asset_2),
                pool_balance_3: coin::value(&pool.asset_3),
            }
        );

        update_pool_lookup<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(false);

        coin_out
    }

    /// First 8 type args define the pool to swap against. X is input coin type & Y is output coin type
    public fun swap_exact_out<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X, Y>(coin_in: Coin<X>, amount_out: u64): (Coin<X>, Coin<Y>) acquires WeightedPool, WeightedPoolLookup {
        assert!(initialized(), ERR_UNINITIALIZED);
        assert!(amount_out > 0, ERR_WEIGHTED_POOL_INVALID_SWAP);

        let (prev_balances, weights) = pool_balances_and_weights<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>();

        let resource_account_address = package::resource_account_address();
        let pool = borrow_global<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);

        let typeof_x = type_info::type_of<X>();
        let typeof_y = type_info::type_of<Y>();
        assert!(typeof_x != typeof_y && !base_pool::is_null<X>() && !base_pool::is_null<Y>(), ERR_WEIGHTED_POOL_INVALID_SWAP);

        let (is_in_0, is_in_1, is_in_2, is_in_3) = (typeof_x == type_info::type_of<Asset0>(), typeof_x == type_info::type_of<Asset1>(), typeof_x == type_info::type_of<Asset2>(), typeof_x == type_info::type_of<Asset3>());
        assert!(is_in_0 || is_in_1 || is_in_2 || is_in_3, ERR_WEIGHTED_POOL_INVALID_SWAP);

        let (is_out_0, is_out_1, is_out_2, is_out_3) = (typeof_y == type_info::type_of<Asset0>(), typeof_y == type_info::type_of<Asset1>(), typeof_y == type_info::type_of<Asset2>(), typeof_y == type_info::type_of<Asset3>());
        assert!(is_out_0 || is_out_1 || is_out_2 || is_out_3, ERR_WEIGHTED_POOL_INVALID_SWAP);

        let idx_in = if (is_in_0) 0 else if (is_in_1) 1 else if (is_in_2) 2 else 3;
        let idx_out = if (is_out_0) 0 else if (is_out_1) 1 else if (is_out_2) 2 else 3;

        // Each asset in the pool must hold some balance after swap
        assert!(amount_out < *vector::borrow(&prev_balances, idx_out), ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

        let provided_amount_in = coin::value(&coin_in);
        assert!(provided_amount_in > 0, ERR_WEIGHTED_POOL_INSUFFICIENT_INPUT);

        // Compute Swap Input
        //  - `amount_in_post_fee` calculated needs to be increased to also include the swap fee. `amount_in_post_fee / (1 - swap_fee_ratio)` represents the
        //  the input necessary to generate `amount_out` with an input that also accounts for the necesarry fee.
        let amount_in_post_fee = weighted_math::calc_in_given_out_weights_u64(idx_in, idx_out, amount_out, &prev_balances, &weights);
        let amount_in = fixed_point64::decode_round_up(fixed_point64::mul(pool.inverse_negated_swap_fee_ratio, amount_in_post_fee));
        assert!(amount_in <= provided_amount_in, ERR_WEIGHTED_POOL_INSUFFICIENT_INPUT);

        let total_fee_amount = amount_in - amount_in_post_fee;
        let protocol_fee_amount = fixed_point64::decode(fixed_point64::mul(base_pool::swap_fee_protocol_allocation_ratio(), total_fee_amount));
        let amount_in_post_protocol_fee = amount_in - protocol_fee_amount;

        // Absorb Protocol Fees
        fees::absorb_fee(coin::extract(&mut coin_in, protocol_fee_amount));

        // Absorb Swapped In Asset. Yield is provided to LPs by their implicit increased in value with lp fees included in `coin_in_swapped`.
        // Since the caller can provide arbitrary input, we extract the exact amount and refund the rest.
        deposit_to_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X>(resource_account_address, idx_in, coin::extract(&mut coin_in, amount_in_post_protocol_fee));

        // Extract Swapped Out Asset
        let coin_out = extract_from_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, Y>(resource_account_address, idx_out, amount_out);

        let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
        
        event::emit_event<SwapEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(
            &mut pool.events.swap_events,
            SwapEvent { 
                idx_in, idx_out,
                amount_in, amount_out, 
                fee_amount: total_fee_amount,
                pool_balance_0: coin::value(&pool.asset_0),
                pool_balance_1: coin::value(&pool.asset_1),
                pool_balance_2: coin::value(&pool.asset_2),
                pool_balance_3: coin::value(&pool.asset_3),
            }
        );

        update_pool_lookup<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(false);

        (coin_in, coin_out)
    }

    // Public Getters

    public fun initialized(): bool {
        exists<WeightedPoolParams>(package::resource_account_address())
    }

    #[view]
    public fun weighted_pool_exists<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): bool {
        let resource_account_address = package::resource_account_address();
        exists<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address)
    }
    
    #[view]
    // Returns pool balances, weights, and lp coin supply
    public fun pool_info(lp_coin_name: String): (vector<u64>, vector<u64>, u64) acquires WeightedPoolLookup {
        let lookup = borrow_global<WeightedPoolLookup>(package::resource_account_address());
        assert!(table::contains(&lookup.name_to_pool, lp_coin_name), ERR_WEIGHTED_POOL_NOT_EXISTS);

        let info = *table::borrow(&lookup.name_to_pool, lp_coin_name);
        (info.balances, info.weights, info.lp_coin_supply)
    }

    #[view]
    public fun pool_balances_and_weights<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): (vector<u64>, vector<u64>)
    acquires WeightedPool {
        let resource_account_address = package::resource_account_address();
        let pool = borrow_global<WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);

        let weights = vector<u64>[get_weight<Weight0>(), get_weight<Weight1>()];
        if (!base_pool::is_null<Weight2>()) vector::push_back(&mut weights, get_weight<Weight2>());
        if (!base_pool::is_null<Weight3>()) vector::push_back(&mut weights, get_weight<Weight3>());

        (pool_balances(pool), weights)
    }

    #[view]
    public fun next_pool_id(): u64 acquires WeightedPoolLookup {
        let lookup = borrow_global<WeightedPoolLookup>(package::resource_account_address());
        lookup.next_id
    }

    #[view]
    public fun lp_name_by_id(id: u64): String acquires WeightedPoolLookup {
        let lookup = borrow_global<WeightedPoolLookup>(package::resource_account_address());
        assert!(table::contains(&lookup.id_to_name, id), ERR_WEIGHTED_POOL_NOT_EXISTS);
        *table::borrow(&lookup.id_to_name, id)
    }
    
    #[view]
    public fun get_weight<WeightN>(): u64 {
        let tpe = type_info::type_of<WeightN>();

        // The boring code can be generated by the one-liner python script:
        // python3 -c "print('if ' + '\nelse if '.join([\"(tpe == type_info::type_of<Weight_%d>()) %d\" % (i*5, i*5) for i in range(1,20)]))"
        if (tpe == type_info::type_of<base_pool::Null>()) 0
        else if (tpe == type_info::type_of<Weight_5>()) 5
        else if (tpe == type_info::type_of<Weight_10>()) 10
        else if (tpe == type_info::type_of<Weight_15>()) 15
        else if (tpe == type_info::type_of<Weight_20>()) 20
        else if (tpe == type_info::type_of<Weight_25>()) 25
        else if (tpe == type_info::type_of<Weight_30>()) 30
        else if (tpe == type_info::type_of<Weight_35>()) 35
        else if (tpe == type_info::type_of<Weight_40>()) 40
        else if (tpe == type_info::type_of<Weight_45>()) 45
        else if (tpe == type_info::type_of<Weight_50>()) 50
        else if (tpe == type_info::type_of<Weight_55>()) 55
        else if (tpe == type_info::type_of<Weight_60>()) 60
        else if (tpe == type_info::type_of<Weight_65>()) 65
        else if (tpe == type_info::type_of<Weight_70>()) 70
        else if (tpe == type_info::type_of<Weight_75>()) 75
        else if (tpe == type_info::type_of<Weight_80>()) 80
        else if (tpe == type_info::type_of<Weight_85>()) 85
        else if (tpe == type_info::type_of<Weight_90>()) 90
        else if (tpe == type_info::type_of<Weight_95>()) 95
        else abort ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHT
    }

    // Internal Helpers

    // Ensures that the balance for the asset extracted never reaches zero
    // CONTRACT: `CoinOut` is one of the listed asset types
    fun extract_from_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, CoinOut>(
        resource_account_address: address,
        idx: u64,
        amount_out: u64
    ): Coin<CoinOut> acquires WeightedPool {
        if (idx == 0) {
            let pool = borrow_global_mut<WeightedPool<CoinOut, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            assert!(amount_out < coin::value(&pool.asset_0), ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

            coin::extract(&mut pool.asset_0, amount_out)
        } else if (idx == 1) {
            let pool = borrow_global_mut<WeightedPool<Asset0, CoinOut, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            assert!(amount_out < coin::value(&pool.asset_1), ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

            coin::extract(&mut pool.asset_1, amount_out)
        } else if (idx == 2) {
            let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, CoinOut, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            assert!(amount_out < coin::value(&pool.asset_2), ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

            coin::extract(&mut pool.asset_2, amount_out)
        } else {
            let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, CoinOut, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            assert!(amount_out < coin::value(&pool.asset_3), ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY);

            coin::extract(&mut pool.asset_3, amount_out)
        }
    }

    // CONTRACT: `CoinIn` is one of the listed Asset Types
    fun deposit_to_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, CoinIn>(
        resource_account_address: address,
        idx: u64,
        coin: Coin<CoinIn>
    ) acquires WeightedPool {
        if (idx == 0) {
            let pool = borrow_global_mut<WeightedPool<CoinIn, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            coin::merge(&mut pool.asset_0, coin)
        } else if (idx == 1) {
            let pool = borrow_global_mut<WeightedPool<Asset0, CoinIn, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            coin::merge(&mut pool.asset_1, coin)
        } else if (idx == 2) {
            let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, CoinIn, Asset3, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            coin::merge(&mut pool.asset_2, coin)
        } else {
            let pool = borrow_global_mut<WeightedPool<Asset0, Asset1, Asset2, CoinIn, Weight0, Weight1, Weight2, Weight3>>(resource_account_address);
            coin::merge(&mut pool.asset_3, coin)
        }
    }

    /// Use current status of global variable "WeightedPool" to update the pool info in the lookup table
    fun update_pool_lookup<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(new_pool: bool) acquires WeightedPoolLookup, WeightedPool {
        let (balances, weights) = pool_balances_and_weights<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>();
        
        let lookup = borrow_global_mut<WeightedPoolLookup>(package::resource_account_address());
        let name = type_info::type_name<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>();
        table::upsert(&mut lookup.name_to_pool, name, WeightedPoolInfo {
            balances,
            weights,
            lp_coin_supply: base_pool::pool_token_supply<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>()
        });

        // If it's a new pool, add it to the ID -> name lookup table and increment the next ID
        if (new_pool) {
            table::add(&mut lookup.id_to_name, lookup.next_id, name);
            lookup.next_id = lookup.next_id + 1;
        }
    }

    fun lp_short_name<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): String {
        let name = string::utf8(b"WP:");
        string::append(&mut name, coin::symbol<Asset0>());
        string::append(&mut name, string::utf8(b"-"));
        string::append(&mut name, u64_to_string(get_weight<Weight0>()));
        string::append(&mut name, string::utf8(b"-"));
        string::append(&mut name, coin::symbol<Asset1>());
        string::append(&mut name, string::utf8(b"-"));
        string::append(&mut name, u64_to_string(get_weight<Weight1>()));

        if (!base_pool::is_null<Asset2>()) {
            string::append(&mut name, string::utf8(b"-"));
            string::append(&mut name, coin::symbol<Asset2>());
            string::append(&mut name, string::utf8(b"-"));
            string::append(&mut name, u64_to_string(get_weight<Weight2>()));

            // Asset3 can only be non-null if Asset 2 was non-null
            if (!base_pool::is_null<Asset3>()) {
                string::append(&mut name, string::utf8(b"-"));
                string::append(&mut name, coin::symbol<Asset3>());
                string::append(&mut name, string::utf8(b"-"));
                string::append(&mut name, u64_to_string(get_weight<Weight3>()));
            };
        };

        // `coin.move` specifies a limit of 32 characters for a name. If we exceed this limit
        // we truncate and replace the last 3 characters with "..." to indicate that the name is too long
        if (string::length(&name) > 32) {
            name = string::sub_string(&name, 0, 29);
            string::append(&mut name, string::utf8(b"..."));
        };

        name
    }

    fun pool_balances<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        pool: &WeightedPool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>
    ): vector<u64> {
        let balances = vector<u64>[coin::value(&pool.asset_0), coin::value(&pool.asset_1)];
        if (!base_pool::is_null<Weight2>()) vector::push_back(&mut balances, coin::value(&pool.asset_2));
        if (!base_pool::is_null<Weight3>()) vector::push_back(&mut balances, coin::value(&pool.asset_3));

        balances
    }

    // Reference: https://github.com/pentagonxyz/movemate/blob/main/aptos/sources/to_string.move
    fun u64_to_string(value: u64): String {
        if (value == 0) return string::utf8(b"0");

        let buffer = vector::empty<u8>();
        while (value != 0) {
            vector::push_back(&mut buffer, ((48 + value % 10) as u8));
            value = value / 10;
        };

        vector::reverse(&mut buffer);
        string::utf8(buffer)
    }
    
    #[test_only]
    use thalaswap::base_pool::Null;

    #[test_only]
    struct FakeCoin_A {}

    #[test_only]
    struct FakeCoin_B {}

    #[test_only]
    struct CapabilitiesHolder<phantom CoinType> has key {
        mint: MintCapability<CoinType>,
        burn: BurnCapability<CoinType>,
        freeze: coin::FreezeCapability<CoinType>
    }

    #[test]
    fun test_u64_to_string() {
        assert!(b"0" == *string::bytes(&u64_to_string(0)), 0);
        assert!(b"1" == *string::bytes(&u64_to_string(1)), 0);
        assert!(b"257" == *string::bytes(&u64_to_string(257)), 0);
        assert!(b"10" == *string::bytes(&u64_to_string(10)), 0);
        assert!(b"12345678" == *string::bytes(&u64_to_string(12345678)), 0);
        assert!(b"18446744073709551615" == *string::bytes(&u64_to_string(18446744073709551615)), 0); // MAX_U64
    }

    #[test]
    #[expected_failure(abort_code = ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHT)]
    fun test_get_weight_invalid_weight_err() {
        get_weight<FakeCoin_A>();
    }

    #[test(manager = @thalaswap)]
    fun test_lp_short_name_ok(manager: &signer) {
        // prepare
        let (burn, freeze, mint) = coin::initialize<FakeCoin_A>(manager, string::utf8(b"FakeCoin_A"), string::utf8(b"FCA"), 0, false);
        move_to(manager, CapabilitiesHolder { mint, burn, freeze });

        let (burn, freeze, mint) = coin::initialize<FakeCoin_B>(manager, string::utf8(b"FakeCoin_B"), string::utf8(b"FCB"), 0, false);
        move_to(manager, CapabilitiesHolder { mint, burn, freeze });

        // test
        let name = lp_short_name<FakeCoin_A, FakeCoin_B, Null, Null, Weight_10, Weight_15, Null, Null>();  
        assert!(name  == string::utf8(b"WP:FCA-10-FCB-15"), 0);

        let name = lp_short_name<FakeCoin_A, FakeCoin_B, FakeCoin_A, Null, Weight_10, Weight_15, Weight_50, Null>();  
        assert!(name == string::utf8(b"WP:FCA-10-FCB-15-FCA-50"), 0);

        let name = lp_short_name<FakeCoin_A, FakeCoin_B, FakeCoin_A, FakeCoin_B, Weight_10, Weight_15, Weight_50, Weight_5>();  
        assert!(name == string::utf8(b"WP:FCA-10-FCB-15-FCA-50-FCB-5"), 0);
    }

    #[test(manager = @thalaswap)]
    fun test_lp_short_name_truncate_ok(manager: &signer) {
        // prepare
        let (burn, freeze, mint) = coin::initialize<FakeCoin_A>(manager, string::utf8(b"F"), string::utf8(b"FFFFFFFFFF"), 0, false);
        move_to(manager, CapabilitiesHolder { mint, burn, freeze });

        // test. 30 characters of symbols + "SP:" > 32 limit
        let name = lp_short_name<FakeCoin_A, FakeCoin_A, FakeCoin_A, Null, Weight_10, Weight_15, Weight_20, Null>();
        assert!(name == string::utf8(b"WP:FFFFFFFFFF-10-FFFFFFFFFF-1..."), 0);
    }
}
